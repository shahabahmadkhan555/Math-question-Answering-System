# -*- coding: utf-8 -*-
"""ConversionToLogicalForm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DiS2ITf_6n-rZhZFZCEH9AcO0VIXNX1T

Refrences - 
https://itvoyagers.in/infix-to-prefix-conversion-using-python/

Import Statements
"""

import re
import json
import nltk
from nltk.tag import hmm
from nltk.corpus import treebank
from nltk.tbl.template import Template 
from nltk.tag.brill import Pos, Word, brill24,fntbl37
from nltk.tag import untag, RegexpTagger, BrillTaggerTrainer
from nltk.corpus import treebank
from nltk.tag import UnigramTagger
from nltk.tag import tnt
import ast

"""Installing NLTK"""

!pip install nltk==3.4.1

nltk.download('all')

"""Converting every equation to latex form in the training set. While training tagger, remove //("""

def tokenizer(sentence):
  equation_check_list = ['=', '/', '*', '+', '-', '%', '\\frac', '<', '>']
  temp_list = []
  final_list = []
  x = sentence.split('\\(')
  for i in x:
    temp_list.append(i.split('\\)'))
  for j in range(len(temp_list)):
    for k in range(len(temp_list[j])):
      if not (any(eq in temp_list[j][k] for eq in equation_check_list)):
        res = re.findall("[a-zA-Z0-9\.\?]+", temp_list[j][k])
        final_list.append(res)
      else:
        final_list.append(temp_list[j][k])
  ans = []
  for i in range(len(final_list)):
    if isinstance(final_list[i], list):
      for j in range(len(final_list[i])):
        ans.append(final_list[i][j])
    else:
      ans.append(final_list[i])
  return ans

print(tokenizer("If \\(x+2=4\\) , find x ."))

"""Reading Annotated Data"""

with open('/content/Final.json') as f:
    data = f.read()
res = ast.literal_eval(data)
print(res)

data = []
for ques in res:
  tagged_res = ques['TaggedQuestion']
  tagged_ques =[]
  for j in tagged_res:
    try:
      tagged_ques.append((j[0],j[1]))
    except:
      print(j)
  data.append(tagged_ques)

training_data = data[:100]
gold_data = data[100:]
testing_data = [untag(s) for s in gold_data]
print(testing_data)

"""Training Data

1. HMM tagger
"""

hmm_trainer = hmm.HiddenMarkovModelTrainer()
hmm_tagger = hmm_trainer.train_supervised(training_data)
#print(testing_data[0])
#print(hmm_tagger.tag(testing_data[0]))

"""2. Brill Tagger"""

unigram_tagger = UnigramTagger(training_data)

tnt_tagger = tnt.TnT() 
tnt_tagger.train(training_data)

# templates = [Template(Pos([-1])),Template(Pos([1])),Template(Pos([-2])),Template(Pos([2])),Template(Pos([-2, -1])),Template(Pos([1, 2])),Template(Pos([-3, -2, -1])),Template(Pos([1, 2, 3])),Template(Pos([-1]), Pos([1])),Template(Word([-1])),Template(Word([1])),Template(Word([-2])),Template(Word([2])),Template(Word([-2, -1])),Template(Word([1, 2])),Template(Word([-3, -2, -1])),Template(Word([1, 2, 3])),Template(Word([-1]), Word([1])),]
templates = fntbl37()
brill_trainer = BrillTaggerTrainer(tnt_tagger, templates, trace=3)
brill_tagger = brill_trainer.train(training_data, max_rules=500)

print(brill_tagger.rules())

"""Evaluating Tagger"""

brill_tagger.evaluate(gold_data)

"""Using the POS tagger"""

def pos_tag(sentence):
  sentence = tokenizer(sentence)
  return brill_tagger.tag(sentence)

print(pos_tag("If \\(x = \\frac { w^2 } { y } \\) and \\(y = \\frac { 1 } { w^2 } \\), what is the value of \\(\\frac { x } { y } \\) in terms of \\(w\\) ?"))

"""---

CONVERTING QUESTION TO LOGICAL FORM


---

Prerequisites
"""

!pip install antlr4_python2_runtime

!git clone https://github.com/augustt198/latex2sympy.git

!apt install antlr4

cd /content/latex2sympy

ls

!antlr4 PS.g4 -o gen

from process_latex import process_sympy

"""Conversion to Mathematical form"""

# using try-except to handle in case of failure
def convertToMathematicalform(text):
  try:
    #print(text)
    x = str(process_sympy(text))
    if '**' in x:
      x = x.replace('**','^')
    return x
  except Exception as e:
    #print(e)
    return str(text)

x = convertToMathematicalform('2^x=5')
print(x)

"""Conversion to prefix form"""

class infix_to_prefix:
    precedence={'^':6,'*':5,'/':5,'+':4,'-':4,'(':3,')':2, '=':1, '<':1, '>':1}
    def __init__(self):
        self.items=[]
        self.size=-1
    def push(self,value):
        self.items.append(value)
        self.size+=1
    def pop(self):
        if self.isempty():
            return 0
        else:
            self.size-=1
            return self.items.pop()
    def isempty(self):
        if(self.size==-1):
            return True
        else:
            return False
    def seek(self):
        if self.isempty():
            return False
        else:
            return self.items[self.size]
    def is0perand(self,i):
        if i.isalpha() or i in '1234567890':
            return True
        else:
            return False
    def reverse(self,expr):
        rev=""
        for i in expr:
            if i is '(':
                i=')'
            elif i is ')':
                i='('
            rev=i+rev
        return rev
    def infixtoprefix (self,expr):
        prefix=""
        for i in expr:
            #if(len(expr)%2==0):
            #    print("Incorrect infix expr")
            #    return False
            if(self.is0perand(i)):
                prefix = prefix + " " + i
            elif(i in '+-*/^=<>'):
                while(len(self.items)and self.precedence[i] < self.precedence[self.seek()]):
                    prefix=prefix + '('+self.pop() + " "
                self.push(i)
            elif i is '(':
                self.push(i)
            elif i is ')':
                o=self.pop()
                while o!='(':
                    prefix +=o
                    o=self.pop()
                #prefix = prefix + '('
                #end of for
        while len(self.items):
            if(self.seek()=='('):
                self.pop()
            prefix+=self.pop()
        return prefix

class infix_to_prefix2:
    precedence={'^':6,'*':5,'/':5,'+':4,'-':4,'(':3,')':2, '=':1, '<':1, '>':1}
    def __init__(self):
        self.items=[]
        self.size=-1
    def push(self,value):
        self.items.append(value)
        self.size+=1
    def pop(self):
        if self.isempty():
            return 0
        else:
            self.size-=1
            return self.items.pop()
    def isempty(self):
        if(self.size==-1):
            return True
        else:
            return False
    def seek(self):
        if self.isempty():
            return False
        else:
            return self.items[self.size]
    def is0perand(self,i):
        if i.isalpha() or i in '1234567890':
            return True
        else:
            return False
    def reverse(self,expr):
        rev=""
        for i in expr:
            if i is '(':
                i=')'
            elif i is ')':
                i='('
            rev=i+rev
        return rev
    def infixtoprefix (self,expr):
        prefix=""
        pointer = 0
        for i in expr:
            #if(len(expr)%2==0):
            #    print("Incorrect infix expr")
            #    return False
            if(self.is0perand(i)):
              if pointer != len(expr)-1:
                prefix = prefix + "(" + i
              else:
                 prefix = prefix + " " + i
            elif(i in '+-*/^<>='):
                while(len(self.items)and self.precedence[i] < self.precedence[self.seek()]):
                    prefix=prefix + '('+self.pop()
                self.push(i)
            elif i is '(':
                self.push(i)
            elif i is ')':
                o=self.pop()
                while o!='(':
                    prefix = prefix + str(o)
                    o=self.pop()
                #prefix = prefix + ')'
                #end of for
            pointer += 1
        while len(self.items):
            if(self.seek()=='('):
                self.pop()
            prefix+=')'+self.pop()
        return prefix

def convert2prefix(expression):
  s=infix_to_prefix2()
  rev=""
  rev=s.reverse(expression)
  result=s.infixtoprefix(rev)
  prefix = result
  if (result!=False):
    prefix=s.reverse(result)
  return prefix

"""Building the structure of logical form."""

# question ---> dictionary of original question with tagged question 
# equations ---> dic with original equation as key and equation in prefix form as value
# question['tagged_question'] --> POS tagged Question
import string
pointer = 0
def convert_to_logical_form(question,equations):
  logical_form_dic ={}
  logical_form_dic['id'] = question['id']
  logical_form = []
  # tags = ['']
  solution_type = 'D'
  if len(question['choices'])!=0:
    logical_form.append('(assert (Strategy \"CheckUnsatisfiable\"))')
    solution_type = 'C'
  else:
    logical_form.append('(assert (Strategy "DirectSolution"))')
  # need dependency parsing for handling the condition tag
  # traversing over whole tagged sentence
  variables = []  # storing all the variables in it

  op =False # check for op tag
  # finding the position of last variable or tag
  last =''
  last_type =' '
  for wordtag in question['tagged_question']:
    if wordtag[1] == 'VAL' :
      last = wordtag[0]
      last_type ='VAL'
    elif wordtag[1] == 'FORM':
      last = wordtag[0]
      last_type ='FORM'
    #elif wordtag[1] == 'OP':
    #  op = True
  val_id = '?_id_'+str(pointer)  
  #print('val_id',val_id)
  #print('last',last)
 # print('last_type',last_type)
 # print('Logical Form', logical_form)
  # traversing through the sentence to convert into logical form
  # Assumption - 1. Right now considering for condition tag the previous variable for the condition
  # Assumption - 2. Computing the value of last variable or equation
  for wrd in question['tagged_question']:
   # print(wrd)
    if wrd[1] == 'VAL':
      variables.append(wrd[0])
    elif wrd[1] == 'FORM':
      if wrd[1] == last:
        continue
      try:
        logical_form.append('(assert ('+equations[wrd[0]] +'))')
      except:
        continue
    elif wrd[1] == 'Integer':
      try:
        if variables[len(variables) -1] == last:
          logical_form.append('(assert (IsInteger '+val_id +'))')
        else:
          logical_form.append('(assert (IsInteger '+ variables[len(variables) -1]+'))')
      except:
        continue
    # elif wrd[0] == wrd[1] and (wrd[0] not in string.punctuation):
    #   try:
    #     if variables[len(variables) -1] == last:
    #       logical_form.append('(assert ('+wrd[0]+' '+val_id+'))')
    #     else:
    #       logical_form.append('(assert ('+wrd[0]+' '+variables[len(variables) -1]+'))')
    #   except:
    #     continue
   # print(logical_form)
  #print('logical_form in the end of loop',logical_form)
  #print('solution_type',solution_type)
  if solution_type == 'D':
    if last_type == 'FORM':
      logical_form.append('(assert (= '+val_id+ equations[last]+'))')
    else:
      logical_form.append('(assert (= '+val_id+ last+'))')
  else:
    if last_type == 'FORM':
      logical_form.append('(assert (Not (= '+val_id+ equations[last]+'))')
    else:
      logical_form.append('(assert (Not (=  '+val_id+ last+'))')
  #print('logical_form after last assert',logical_form)  
  # adding menu and combo meals assert statement
  if op == False:
    #print('here')
    for c in question['choices']:
      logical_form.append('(assert (MenuItem'+ ' "' + c+'" ' +question['choices'][c] + "))")
    #print(logical_form)
  else:
    for o in question['options']:
      logical_form.append('(assert (MenuItem'+ ' "' + o+'" ' +question['options'][o] + "))")
    for c in question['choices']:
      if question['choices'][c] == 'None':
        logical_form.append('(assert (ComboItem' + ' "' + c+'" ' +'noneOfTheAbove' + '))' ) 
      else:
        for o in question['options']:
          if o in question['choices'][c]:
            logical_form.append('(assert (ComboItem'+ ' '+c+' '  +o+' ' +'))' )
    #print(logical_form)
  logical_form_dic['logicalForm'] = logical_form
  return logical_form_dic

def readData():
  with open('/content/data.json') as json_file:
    data = json.load(json_file)
  return data

def find_equation(tagged_question):
  equations = dict()
  prefix_eq = []
  equation_check_list = ['=', '/', '*', '+', '-', '%', '\\frac', '<', '>']

  for i in range(len(tagged_question)):
    if tagged_question[i][1] == 'Unk' and (any(eq in tagged_question[i][0] for eq in equation_check_list)):
      tagged_question[i] =(tagged_question[i][0],'FORM')
     # print(tagged_question[i][0])
      eq = tagged_question[i][0]
      eq = eq.replace("\\(", '')
      eq = eq.replace("\\)", '')
      # print("hello I am mad", str(eq))
      math_equation = convertToMathematicalform(eq)
      #print(math_equation)
      if 'Eq' in math_equation:
        #print("hello")
        index = math_equation.find(",")
        one = math_equation[3:index]
        two = math_equation[index+1:-1]
        math_equation = one + " =" + " " +two
      #print(math_equation)
      eq_in_prefix_form = convert2prefix(math_equation)
      #print(math_equation)
      # print(eq_in_prefix_form)
      eq_in_prefix_form = eq_in_prefix_form.replace('^', 'Pow')
      equations[eq] = eq_in_prefix_form

  return equations

#def find_options(tagged_question):
#  options = dict()
#  for i in range(len(tagged_question)):
#    if

if __name__ == "__main__":
  questions = readData()
  #questions = [
  #  {
  #      "answer": "",
  #      "choices": {
  #          "A": "18",
  #          "B": "35",
  #          "C": "45",
  #          "D": "60",
  #          "E": "72"
  #      },
  #      "exam": "source2",
  #      "id": 20000,
  #      "originalQuestionNumber": 3,
  #      "question": "If \\(x ^ 2 = 4\\) , find x .",
  #      "sectionLength": 16,
  #      "sectionNumber": 7,
  #      "tags": [
  #          "closed"
  #      ]
  #  }]
  logical_forms = []
  for i in range(len(questions)):
    input_question = questions[i]
    question = questions[i]['question']
    question = question.replace('.', '')
    question = question.replace('?', '')
    question = question.replace('!', '')
    tagged_question = pos_tag(question)
    # print(tagged_question)
    input_question['tagged_question'] = tagged_question
    eq = find_equation(tagged_question)
    #op = find_options(tagged_question)
    #input_question['options'] = op
    # print(eq)
    print(tagged_question)
    logical_form = convert_to_logical_form(input_question, eq)
    logical_forms.append(logical_form)
  
  with open('/content/LogicalForms.json', 'w') as output_file:
    json.dump(logical_forms, output_file, indent = 2)

with open('/content/LOgical_Forms.json', 'w') as outfile:
    json.dump(new_training_data, outfile,indent=2)









